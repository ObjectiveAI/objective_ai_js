import OpenAI from "openai";
import { Stream } from "openai/streaming";
import { JsonValue, QueryChatCompletionChunk } from "./query";

/**
 * Represents a streamed chunk of a chat completion response returned by the model,
 * based on the provided input.
 * [Learn more](https://platform.openai.com/docs/guides/streaming-responses).
 */
export interface QueryToolChatCompletionChunk
  extends OpenAI.ChatCompletionChunk {
  /**
   * A list of Query chat completion choices.
   */
  choices: Array<QueryToolChatCompletionChunk.Choice>;
}

export namespace QueryToolChatCompletionChunk {
  /**
   * Merges two QueryToolChatCompletionChunk objects.
   * @param self - The first QueryToolChatCompletionChunk object.
   * @param chunk - The next QueryToolChatCompletionChunk object to merge with the first.
   * @returns A new merged QueryToolChatCompletionChunk object.
   */
  export function merged(
    self: QueryToolChatCompletionChunk,
    { choices, usage }: QueryToolChatCompletionChunk
  ): QueryToolChatCompletionChunk {
    const merged = { ...self, choices: [...self.choices] };
    for (const choice of choices) {
      const selfChoiceIndex = merged.choices.findIndex(
        (c) => c.index === choice.index
      );
      if (selfChoiceIndex >= 0) {
        merged.choices = [
          ...merged.choices.slice(0, selfChoiceIndex),
          Choice.merged(merged.choices[selfChoiceIndex], choice),
          ...merged.choices.slice(selfChoiceIndex + 1),
        ];
      } else {
        merged.choices = [...merged.choices, choice];
      }
    }
    if (merged.usage === undefined || merged.usage === null) {
      merged.usage = usage;
    }
    return merged;
  }

  /**
   * Converts an OpenAI chat completion chunk to a Query Tool chat completion chunk.
   * @param chunk - The OpenAI chat completion chunk to convert.
   * @returns The converted Query Tool chat completion chunk.
   */
  export function fromOpenAIChatCompletionChunk(
    chunk: OpenAI.ChatCompletionChunk
  ): QueryToolChatCompletionChunk {
    return {
      ...chunk,
      choices: chunk.choices.map(Choice.fromOpenAIChoice),
    };
  }

  export interface Choice extends OpenAI.ChatCompletionChunk.Choice {
    /**
     * A Query Tool completion delta generated by streamed model responses.
     */
    delta: Choice.Delta;
  }

  export namespace Choice {
    /**
     * Merges two Choice objects.
     * @param self - The first Choice object.
     * @param chunk - The next Choice object to merge with the first.
     * @returns A new merged Choice object.
     */
    export function merged(
      self: Choice,
      { delta, finish_reason, logprobs }: Choice
    ): Choice {
      return {
        delta: Delta.merged(self.delta, delta),
        finish_reason: self.finish_reason ?? finish_reason,
        index: self.index,
        logprobs: self.logprobs ?? logprobs,
      };
    }

    /**
     * Converts an OpenAI chat completion chunk choice to a Query Tool chat completion chunk choice.
     * @param choice - The OpenAI chat completion chunk choice to convert.
     * @returns The converted Query Tool chat completion chunk choice.
     */
    export function fromOpenAIChoice(
      choice: OpenAI.ChatCompletionChunk.Choice
    ): Choice {
      return {
        ...choice,
        delta: Delta.fromOpenAIDelta(choice.delta),
      };
    }

    /**
     * A Query completion delta generated by streamed model responses.
     */
    export type Delta =
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content: string;
          /**
           * The native JSON contents of the Query Tool completion delta.
           */
          query_tool_content: JsonValue;
          /**
           * The reasoning of the chunk message.
           */
          reasoning: string;
          /**
           * The native JSON reasoning of the Query Tool completion delta.
           */
          parsed_reasoning: QueryChatCompletionChunk[];
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content: null;
          /**
           * The native JSON contents of the Query Tool completion delta.
           */
          query_tool_content: null;
          /**
           * The reasoning of the chunk message.
           */
          reasoning: string;
          /**
           * The native JSON reasoning of the Query Tool completion delta.
           */
          parsed_reasoning: QueryChatCompletionChunk[];
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content?: undefined;
          /**
           * The native JSON contents of the Query Tool completion delta.
           */
          query_tool_content?: undefined;
          /**
           * The reasoning of the chunk message.
           */
          reasoning: string;
          /**
           * The native JSON reasoning of the Query Tool completion delta.
           */
          parsed_reasoning: QueryChatCompletionChunk[];
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content: null;
          /**
           * The native JSON contents of the Query Tool completion delta.
           */
          query_tool_content: null;
          /**
           * The reasoning of the chunk message.
           */
          reasoning?: undefined;
          /**
           * The native JSON reasoning of the Query Tool completion delta.
           */
          parsed_reasoning?: undefined;
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content?: undefined;
          /**
           * The native JSON contents of the Query Tool completion delta.
           */
          query_tool_content?: undefined;
          /**
           * The reasoning of the chunk message.
           */
          reasoning?: undefined;
          /**
           * The native JSON reasoning of the Query Tool completion delta.
           */
          parsed_reasoning?: undefined;
        });

    export namespace Delta {
      /**
       * Merges two Delta objects.
       * @param self - The first Delta object.
       * @param chunk - The next Delta object to merge with the first.
       * @returns A new merged Delta object.
       */
      export function merged(
        {
          content: selfContent,
          reasoning: selfReasoning,
          parsed_reasoning: selfParsedReasoning,
          refusal: selfRefusal,
          role: selfRole,
          tool_calls: selfToolCalls,
        }: Delta,
        {
          content: mergeContent,
          reasoning: mergeReasoning,
          parsed_reasoning: mergeParsedReasoning,
          refusal: mergeRefusal,
          role: mergeRole,
          tool_calls: mergeToolCalls_,
        }: Delta
      ): Delta {
        const mergeStrings = (
          a: string | undefined | null,
          b: string | undefined | null
        ): string | undefined | null => {
          if (a === undefined || a === null) {
            return b;
          } else if (b === undefined || b === null) {
            return a;
          } else {
            return a + b;
          }
        };
        const mergeToolCalls = (
          existing:
            | OpenAI.Chat.Completions.ChatCompletionChunk.Choice.Delta.ToolCall[]
            | undefined,
          incoming:
            | OpenAI.Chat.Completions.ChatCompletionChunk.Choice.Delta.ToolCall[]
            | undefined
        ):
          | OpenAI.Chat.Completions.ChatCompletionChunk.Choice.Delta.ToolCall[]
          | undefined => {
          const mergeToolCall = (
            existing: OpenAI.ChatCompletionChunk.Choice.Delta.ToolCall,
            {
              function: function_,
              id,
              type,
            }: OpenAI.ChatCompletionChunk.Choice.Delta.ToolCall
          ): OpenAI.ChatCompletionChunk.Choice.Delta.ToolCall => {
            const mergedToolCall = { ...existing };
            if (mergedToolCall.id === undefined) {
              mergedToolCall.id = id;
            }
            if (mergedToolCall.type === undefined) {
              mergedToolCall.type = type;
            }
            if (mergedToolCall.function === undefined) {
              mergedToolCall.function = function_;
            } else {
              if (mergedToolCall.function.name === undefined) {
                mergedToolCall.function.name = function_?.name;
              }
              if (mergedToolCall.function.arguments === undefined) {
                mergedToolCall.function.arguments = function_?.arguments;
              } else if (function_?.arguments !== undefined) {
                mergedToolCall.function.arguments += function_.arguments;
              }
            }
            return mergedToolCall;
          };
          if (existing === undefined || existing.length === 0) {
            return incoming;
          } else if (incoming === undefined || incoming.length === 0) {
            return existing;
          } else {
            const merged = [...existing];
            for (const toolCall of incoming) {
              const existingToolCallIndex = merged.findIndex(
                (c) => c.id === toolCall.id
              );
              if (existingToolCallIndex >= 0) {
                merged[existingToolCallIndex] = mergeToolCall(
                  merged[existingToolCallIndex],
                  toolCall
                );
              } else {
                merged.push(toolCall);
              }
            }
            return merged;
          }
        };
        const mergedReasoning = mergeStrings(selfReasoning, mergeReasoning);
        let mergedParsedReasoning: QueryChatCompletionChunk[] | undefined;
        if (mergedReasoning) {
          mergedParsedReasoning = [
            ...(selfParsedReasoning ?? []),
            ...(mergeParsedReasoning ?? []),
          ];
        } else {
          mergedParsedReasoning = undefined;
        }
        const content = mergeStrings(selfContent, mergeContent);
        let mergedQueryToolContent: JsonValue | undefined = content
          ? JSON.parse(content)
          : undefined;
        const delta = {
          content,
          query_tool_content: mergedQueryToolContent,
          reasoning: mergedReasoning,
          parsed_reasoning: mergedParsedReasoning,
          refusal: mergeStrings(selfRefusal, mergeRefusal),
          role: mergeRole ?? selfRole,
          tool_calls: mergeToolCalls(selfToolCalls, mergeToolCalls_),
        };
        if (
          delta.reasoning === undefined &&
          delta.parsed_reasoning === undefined
        ) {
          return delta as Delta;
        } else if (delta.reasoning && delta.parsed_reasoning) {
          return delta as Delta;
        } else {
          throw new Error(
            "invalid reasoning delta: reasoning and parsed_reasoning must both be defined or both be undefined."
          );
        }
      }

      /**
       * Converts an OpenAI chat completion chunk choice delta to a Query Tool chat completion chunk choice delta.
       * @param delta - The OpenAI chat completion chunk choice delta to convert.
       * @returns The converted Query Tool chat completion chunk choice delta.
       */
      export function fromOpenAIDelta(
        delta: OpenAI.ChatCompletionChunk.Choice.Delta
      ): Delta {
        const deltaCasted = delta as OpenAI.ChatCompletionChunk.Choice.Delta & {
          reasoning?: string;
        };
        if (deltaCasted.content === undefined) {
          if ("content" in deltaCasted) {
            if (deltaCasted.reasoning === undefined) {
              if ("reasoning" in deltaCasted) {
                // content is present but undefined
                // query_tool_content will be present but undefined
                // reasoning is present but undefined
                // parsed_reasoning will be present but undefined
                return {
                  ...deltaCasted,
                  content: undefined,
                  query_tool_content: undefined,
                  reasoning: undefined,
                  parsed_reasoning: undefined,
                };
              } else {
                // content is present but undefined
                // query_tool_content will be present but undefined
                // reasoning is not present
                // parsed_reasoning will be not present
                return {
                  ...deltaCasted,
                  content: undefined,
                  query_tool_content: undefined,
                } as typeof deltaCasted & {
                  content: undefined;
                  query_tool_content: undefined;
                  reasoning?: undefined;
                  parsed_reasoning?: undefined;
                };
              }
            } else {
              // content is present but undefined
              // query_tool_content will be present but undefined
              // reasoning is present
              // parsed_reasoning will be present
              return {
                ...deltaCasted,
                content: undefined,
                query_tool_content: undefined,
                reasoning: deltaCasted.reasoning,
                parsed_reasoning: deltaCasted.reasoning
                  .split("\n")
                  .map((line) => JSON.parse(line)),
              };
            }
          } else {
            if (deltaCasted.reasoning === undefined) {
              if ("reasoning" in deltaCasted) {
                // content is not present
                // query_tool_content will be not present
                // reasoning is present but undefined
                // parsed_reasoning will be present but undefined
                return {
                  ...deltaCasted,
                  reasoning: undefined,
                  parsed_reasoning: undefined,
                } as typeof deltaCasted & {
                  content: undefined;
                  query_tool_content: undefined;
                  reasoning: undefined;
                  parsed_reasoning: undefined;
                };
              } else {
                // content is not present
                // query_tool_content will be not present
                // reasoning is not present
                // parsed_reasoning will be not present
                return { ...deltaCasted } as typeof deltaCasted & {
                  content?: undefined;
                  query_tool_content?: undefined;
                  reasoning?: undefined;
                  parsed_reasoning?: undefined;
                };
              }
            } else {
              // content is not present
              // query_tool_content will be not present
              // reasoning is present
              // parsed_reasoning will be present
              return {
                ...deltaCasted,
                reasoning: deltaCasted.reasoning,
                parsed_reasoning: deltaCasted.reasoning
                  .split("\n")
                  .map((line) =>
                    QueryChatCompletionChunk.fromOpenAIChatCompletionChunk(
                      JSON.parse(line)
                    )
                  ),
              } as typeof deltaCasted & {
                content?: undefined;
                query_tool_content?: undefined;
                reasoning: string;
                parsed_reasoning: QueryChatCompletionChunk[];
              };
            }
          }
        } else if (deltaCasted.content === null || deltaCasted.content === "") {
          if (deltaCasted.reasoning === undefined) {
            if ("reasoning" in deltaCasted) {
              // content is null
              // query_tool_content will be null
              // reasoning is present but undefined
              // parsed_reasoning will be present but undefined
              return {
                ...deltaCasted,
                content: null,
                query_tool_content: null,
                reasoning: undefined,
                parsed_reasoning: undefined,
              };
            } else {
              // content is null
              // query_tool_content will be null
              // reasoning is not present
              // parsed_reasoning will be not present
              return {
                ...deltaCasted,
                content: null,
                query_tool_content: null,
              } as typeof deltaCasted & {
                content: null;
                query_tool_content: null;
                reasoning?: undefined;
                parsed_reasoning?: undefined;
              };
            }
          } else {
            // content is null
            // query_tool_content will be null
            // reasoning is present
            // parsed_reasoning will be present
            return {
              ...deltaCasted,
              content: null,
              query_tool_content: null,
              reasoning: deltaCasted.reasoning,
              parsed_reasoning: deltaCasted.reasoning
                .split("\n")
                .map((line) =>
                  QueryChatCompletionChunk.fromOpenAIChatCompletionChunk(
                    JSON.parse(line)
                  )
                ),
            };
          }
        } else {
          // content is a string
          // query_tool_content will be a QueryToolAssistantMessageContent
          return {
            ...deltaCasted,
            content: deltaCasted.content,
            query_tool_content: JSON.parse(deltaCasted.content),
            reasoning: deltaCasted.reasoning,
            parsed_reasoning: deltaCasted
              .reasoning!.split("\n")
              .map((line) =>
                QueryChatCompletionChunk.fromOpenAIChatCompletionChunk(
                  JSON.parse(line)
                )
              ),
          } as typeof deltaCasted & {
            content: string;
            query_tool_content: JsonValue;
            reasoning: string;
            parsed_reasoning: QueryChatCompletionChunk[];
          };
        }
      }
    }
  }
}

/**
 * Stream of QueryToolChatCompletionChunk objects.
 * Can be easily constructed from an OpenAI chat completion chunk stream.
 */
export type QueryToolStream = Stream<QueryToolChatCompletionChunk>;

export namespace QueryToolStream {
  /**
   * Converts an OpenAI chat completion chunk stream to a Query Tool chat completion chunk stream.
   * @param chunk - The OpenAI chat completion chunk stream to convert.
   * @returns The converted Query Tool chat completion chunk stream.
   */
  export function fromOpenAIStream(
    stream: Stream<OpenAI.ChatCompletionChunk>
  ): QueryToolStream {
    return new Stream(async function* () {
      for await (const chunk of stream) {
        yield QueryToolChatCompletionChunk.fromOpenAIChatCompletionChunk(chunk);
      }
    }, stream.controller);
  }

  /**
   * Converts an OpenAI chat completion chunk stream to a merged Query Tool chat completion chunk stream.
   * Yields a continuously merged QueryToolChatCompletionChunk object, updating as data comes in.
   * @param chunk - The OpenAI chat completion chunk stream to convert.
   * @returns The converted merged Query Tool chat completion chunk stream.
   */
  export function merged(
    stream: Stream<QueryToolChatCompletionChunk>
  ): QueryToolStream {
    return new Stream(async function* () {
      let merged: QueryToolChatCompletionChunk | null = null;
      for await (const chunk of stream) {
        if (merged === null) {
          merged = chunk;
        } else {
          merged = QueryToolChatCompletionChunk.merged(merged, chunk);
        }
        yield merged;
      }
    }, stream.controller);
  }
}
