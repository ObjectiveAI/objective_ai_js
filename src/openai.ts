import OpenAI from "openai";
import { APIPromise, RequestOptions } from "openai/core";
import { ChatCompletionCreateParamsBase } from "openai/resources/chat/completions";
import { Stream } from "openai/streaming";
import { QueryAssistantMessageContent } from "src";

/**
 * Represents a streamed chunk of a chat completion response returned by the model,
 * based on the provided input.
 * [Learn more](https://platform.openai.com/docs/guides/streaming-responses).
 */
export interface QueryChatCompletionChunk extends OpenAI.ChatCompletionChunk {
  /**
   * A list of Query chat completion choices.
   */
  choices: Array<QueryChatCompletionChunk.Choice>;
}

export namespace QueryChatCompletionChunk {
  /**
   * Merges two QueryChatCompletionChunk objects.
   * @param self - The first QueryChatCompletionChunk object.
   * @param chunk - The next QueryChatCompletionChunk object to merge with the first.
   * @returns A new merged QueryChatCompletionChunk object.
   */
  export function merged(
    self: QueryChatCompletionChunk,
    { choices, usage }: QueryChatCompletionChunk
  ): QueryChatCompletionChunk {
    self.choices.push(...choices);
    if (self.usage === undefined || self.usage === null) {
      self.usage = usage;
    }
    return { ...self };
  }

  /**
   * Converts an OpenAI chat completion chunk to a Query chat completion chunk.
   * @param chunk - The OpenAI chat completion chunk to convert.
   * @returns The converted Query chat completion chunk.
   */
  export function fromOpenAIChatCompletionChunk(
    chunk: OpenAI.ChatCompletionChunk
  ): QueryChatCompletionChunk {
    return {
      ...chunk,
      choices: chunk.choices.map(Choice.fromOpenAIChoice),
    };
  }

  export interface Choice extends OpenAI.ChatCompletionChunk.Choice {
    /**
     * A Query completion delta generated by streamed model responses.
     */
    delta: Choice.Delta;
  }

  export namespace Choice {
    /**
     * Converts an OpenAI chat completion chunk choice to a Query chat completion chunk choice.
     * @param choice - The OpenAI chat completion chunk choice to convert.
     * @returns The converted Query chat completion chunk choice.
     */
    export function fromOpenAIChoice(
      choice: OpenAI.ChatCompletionChunk.Choice
    ): Choice {
      return {
        ...choice,
        delta: Delta.fromOpenAIDelta(choice.delta),
      };
    }

    /**
     * A Query completion delta generated by streamed model responses.
     */
    export type Delta =
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content: string;
          /**
           * The native JSON contents of the Query completion delta.
           */
          query_content: QueryAssistantMessageContent;
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content: null;
          /**
           * The native JSON contents of the Query completion delta.
           */
          query_content: null;
        })
      | (OpenAI.ChatCompletionChunk.Choice.Delta & {
          /**
           * The contents of the chunk message.
           */
          content?: undefined;
          /**
           * The native JSON contents of the Query completion delta.
           */
          query_content?: undefined;
        });

    export namespace Delta {
      /**
       * Converts an OpenAI chat completion chunk choice delta to a Query chat completion chunk choice delta.
       * @param delta - The OpenAI chat completion chunk choice delta to convert.
       * @returns The converted Query chat completion chunk choice delta.
       */
      export function fromOpenAIDelta(
        delta: OpenAI.ChatCompletionChunk.Choice.Delta
      ): Delta {
        if (delta.content === undefined) {
          if ("content" in delta) {
            // content is present but undefined
            // query_content will be present but undefined
            return {
              ...delta,
              content: undefined,
              query_content: undefined,
            };
          } else {
            // content is not present
            // query_content will be not present
            return { ...delta } as Delta;
          }
        } else if (delta.content === null) {
          // content is null
          // query_content will be null
          return {
            ...delta,
            content: null,
            query_content: null,
          };
        } else {
          // content is a string
          // query_content will be a QueryAssistantMessageContent
          return {
            ...delta,
            content: delta.content,
            query_content: QueryAssistantMessageContent.fromString(
              delta.content
            ),
          };
        }
      }
    }
  }
}

/**
 * Represents a chat completion response returned by model, based on the provided
 * input.
 */
export interface QueryChatCompletion extends OpenAI.ChatCompletion {
  /**
   * A list of chat completion choices.
   */
  choices: Array<QueryChatCompletion.Choice>;
}

export namespace QueryChatCompletion {
  /**
   * Converts an OpenAI chat completion choice to a Query chat completion choice.
   * @param choice - The OpenAI chat completion choice to convert.
   * @returns The converted Query chat completion choice.
   */
  export function fromOpenAIChatCompletion(
    chatCompletion: OpenAI.ChatCompletion
  ): QueryChatCompletion {
    return {
      ...chatCompletion,
      choices: chatCompletion.choices.map(Choice.fromOpenAIChoice),
    };
  }

  export interface Choice extends OpenAI.ChatCompletion.Choice {
    /**
     * A query completion message generated by the model.
     */
    message: Choice.Message;
  }

  export namespace Choice {
    /**
     * Converts an OpenAI chat completion choice to a Query chat completion choice.
     * @param choice - The OpenAI chat completion choice to convert.
     * @returns The converted Query chat completion choice.
     */
    export function fromOpenAIChoice(
      choice: OpenAI.ChatCompletion.Choice
    ): Choice {
      return {
        ...choice,
        message: Message.fromOpenAIMessage(choice.message),
      };
    }

    /**
     * A query completion message generated by the model.
     */
    export type Message =
      | (OpenAI.ChatCompletionMessage & {
          /**
           * The contents of the message.
           */
          content: string;
          /**
           * The native JSON contents of the query completion message.
           */
          query_content: QueryAssistantMessageContent;
        })
      | (OpenAI.ChatCompletionMessage & {
          /**
           * The contents of the message.
           */
          content: null;
          /**
           * The native JSON contents of the query completion message.
           */
          query_content: null;
        });

    export namespace Message {
      /**
       * Converts an OpenAI chat completion message to a Query chat completion message.
       * @param message - The OpenAI chat completion message to convert.
       * @returns The converted Query chat completion message.
       */
      export function fromOpenAIMessage(
        message: OpenAI.ChatCompletionMessage
      ): Message {
        if (message.content === null) {
          // content is null
          // query_content will be null
          return { ...message, content: null, query_content: null };
        } else {
          // content is a string
          // query_content will be a QueryAssistantMessageContent
          return {
            ...message,
            content: message.content,
            query_content: QueryAssistantMessageContent.fromString(
              message.content
            ),
          };
        }
      }
    }
  }
}

/**
 * Stream of QueryChatCompletionChunk objects.
 * Can be easily constructed from an OpenAI chat completion chunk stream.
 */
export type QueryStream = Stream<QueryChatCompletionChunk>;

export namespace QueryStream {
  /**
   * Converts an OpenAI chat completion chunk stream to a Query chat completion chunk stream.
   * @param chunk - The OpenAI chat completion chunk stream to convert.
   * @returns The converted Query chat completion chunk stream.
   */
  export function fromOpenAIStream(
    stream: Stream<OpenAI.ChatCompletionChunk>
  ): QueryStream {
    return new Stream(async function* () {
      for await (const chunk of stream) {
        yield QueryChatCompletionChunk.fromOpenAIChatCompletionChunk(chunk);
      }
    }, stream.controller);
  }

  /**
   * Converts an OpenAI chat completion chunk stream to a merged Query chat completion chunk stream.
   * Yields a continuously merged QueryChatCompletionChunk object, updating as data comes in.
   * @param chunk - The OpenAI chat completion chunk stream to convert.
   * @returns The converted merged Query chat completion chunk stream.
   */
  export function merged(
    stream: Stream<QueryChatCompletionChunk>
  ): QueryStream {
    return new Stream(async function* () {
      let merged: QueryChatCompletionChunk | null = null;
      for await (const chunk of stream) {
        if (merged === null) {
          merged = chunk;
        } else {
          merged = QueryChatCompletionChunk.merged(merged, chunk);
        }
        yield merged;
      }
    }, stream.controller);
  }
}

export namespace Query {
  export function create(
    openai: OpenAI,
    body: OpenAI.ChatCompletionCreateParamsNonStreaming,
    options?: RequestOptions
  ): Promise<QueryChatCompletion>;
  export function create(
    openai: OpenAI,
    body: OpenAI.ChatCompletionCreateParamsStreaming,
    options?: RequestOptions
  ): Promise<QueryStream>;
  export function create(
    openai: OpenAI,
    body: ChatCompletionCreateParamsBase,
    options?: RequestOptions
  ): Promise<QueryChatCompletion | QueryStream>;
  export function create(
    openai: OpenAI,
    body: ChatCompletionCreateParamsBase,
    options?: RequestOptions
  ): Promise<QueryChatCompletion> | Promise<QueryStream> {
    const promise = openai.post("/query/completions", {
      body,
      ...options,
      stream: body.stream ?? false,
    }) as
      | APIPromise<OpenAI.ChatCompletion>
      | APIPromise<Stream<OpenAI.ChatCompletionChunk>>;
    if (body.stream) {
      return (promise as APIPromise<Stream<OpenAI.ChatCompletionChunk>>).then(
        (stream) => QueryStream.fromOpenAIStream(stream)
      ) as Promise<QueryStream>;
    } else {
      return (promise as APIPromise<OpenAI.ChatCompletion>).then((response) =>
        QueryChatCompletion.fromOpenAIChatCompletion(response)
      ) as Promise<QueryChatCompletion>;
    }
  }
}
